# 运行时存储布局

### 各种数据对象的内存表示

为了简单起见，我们在Decaf语言中不对浮点数进行支持。并且我们约定：

*   对于int类型的常量和变量，对应于32位整数，即4占字节

*   对于bool类型的常量和变量，使用32位整数实现（通常是用8位整数实现），以0表示false，1表示true

*   对于string类型的常量和变量，用字符串的首地址（32 位）的来表示字符串，字符串本身不记录长度，使用0字符（即'\0'）作为结束符，结束符不是字符串的一部分。这些都与C语言相同

*   对于数组，采用运行时动态分配的方式来分配存储空间，所分配到的存储区域大小为数组长度加1个单元，每个单元为32位（即4字节，以下同），其中第一个单元用于记录数组的长度（数组的length()函数用到这个信息），后面的单元均为数组内容，整个数组用指向第一个元素的指针（32位地址）表示

*   对于类对象，也是采用运行时动态分配的方式来进行存储空间分配，所分配到的区域应该包含以下内容：第一个单元存放着这个对象所对应的类的虚函数表地址（Virtual Table，请回忆C++中关于虚表的概念），这个单元的内容在调用一个类的成员函数的时候起着很重要的作用；后面的单元均用于存放与这个对象相关联的各个成员变量，存储位置越是靠近第一个单元，则该成员变量的“辈分”越高，例如三个类A、B、C有B继承于A而且C又继承于B的关系，这三个类分别有成员变量a、b、c，则对于一个类C的对象来说，a、b、c三者中存储位置最靠近第一个单元的应该是成员变量a，其次是b，离第一个单元最远的应该是c；类对象用指向对应存储区域第一个单元的指针来表示（更详细的说明请参考后面章节）

通过上述规定，在PA3中所有的数据类型都统一为用32位整数实现，任何一个变量或者常量都占用4字节。



### 一般函数调用过程

在这一节我们以C语言中的函数在MIPS机器上的调用过程为例（在x86上的过程类似），介绍一般函数的调用过程。对于C++中的虚函数以及Decaf中的函数，其调用过程略有不同，但基本的原理是相同的。
C语言程序一个典型的函数调用过程是这样的：

a) （调用方）把函数的实际参数按照参数表中从右到左的顺序压栈

b) （调用方）使用跳转语句跳转到函数入口（并把返回地址保存在$ra寄存器中）

c) （调用方或者被调用方）保存好返回地址

d) （被调用方）保存好原基地值寄存器$fp的值

e) （被调用方）把基地值寄存器$fp指向栈顶指针寄存器$sp所指的位置

f) （被调用方）修改栈顶指针寄存器的值$sp，使得$sp和$fp之间的区域足够存放函数的联系单元、局部变量和临时变量等

g) （被调用方）执行函数体代码直到函数返回

h) （被调用方）恢复原来的$sp和$fp

i) （被调用方）跳转回保存好的返回地址所指处

j) （调用方）释放之前压进栈的那些实参的空间（通过弹栈操作）

函数执行的时候的内存布局情况如图所示：

![PA3-2](./pic/PA3-2.png)

所谓活动记录（activity record），就是指当前函数执行所需的局部信息区域，这个区域包括了：传进函数的实参（在调用函数之前压进栈）、联系单元（动态链2和返回地址3）、函数的局部变量和各种临时变量，在诸如PL/0这样的支持函数嵌套定义的语言中，运行时联系单元中还会包括静态链信息。

在函数体中，访问函数的一个形式参数实际上是对实参区域进行访问，此时需要使用当前的基地值寄存器$fp加上该形参相对于当前栈帧首地址的偏移量进行访问，这是因为虽然在运行的时候存放着该形参内容的内存单元的地址在编译的时候是不可预先知道的，但是这个单元在活动记录中的位置在编译的时候是可以预知的。同样的访问方式也适合于对函数的局部变量以及临时变量的访问中。可见，在这种意义下，函数的参数、局部变量、临时变量三者并没有实质的区别，因此在Decaf代码框架中我们都使用Temp对象来表示这三种数据对象，其中唯一不同的是实参相对于当前栈帧首地址的偏移量是需要在PA3中预先算好的，而局部变量和临时变量的偏移量都是在PA4中进行数据流分析以后才确定（实际上可能使用寄存器就已经足够了，不需要偏量）。

在这次的decaf tac描述中，我们使用PARM来表示参数的传递，因此在TAC层实际上隐藏了实际的入栈操作，我们只需要按照从左到右的顺序传递参数即可。需要注意的地方是，TAC模拟器在执行时会将PARM传递的参数当做这个PARM之后第一次碰到的CALL的参数。

### 运行时存储布局


一般来说，程序运行时的内存空间从逻辑上分为“代码区”和“数据区”两个主要部分。顾名思义，代码区用于存放可执行的代码，而数据区用于存放程序运行所需的数据（例如临时变量、虚函数表的空间等等）。

数据区按照所存放的数据和对应的管理方法分为全局数据区（静态数据区）、栈区、堆区三部分，这三个区里面的存储空间分配分别遵循三种不同的规则：静态存储分配（Static Memory Allocation）、栈式存储分配（Stack-based Allocation）和堆式存储分配（Heap-based Allocation），其中后两种分配方式称为“动态存储分配”，因为这两种方式中存储空间并不是在编译的时候静态分配好的，而是在运行时才进行的。
#### 全局数据区（静态数据区）
全局/静态数据区用于存放各种全局变量、静态变量还有类的虚函数表。静态存储分配的结果是编译的时候确定的，在进行编译的时候编译器根据全局变量等信息事先计算好所需的存储空间以及各变量在这个存储空间中的偏移地址。在C语言中全局数组的存储分配方法即为静态存储分配。
静态存储分配并不是总适用的，对于一些动态的数据结构，例如动态数组（C++中使用new关键字来分配内存）以及可重入函数的局部变量（例如Hanoi Tower问题中递归函数的局部变量）等最终空间大小必须在运行时才能确定的场合静态存储分配通常无能为力。
#### 栈区
栈区顾名思义就是作为“栈”这样一种数据结构来使用的。栈区数据空间的存储管理方式称为栈式存储分配。与静态存储分配方式不同，栈式存储分配是动态的，也就是说必须是运行的时候才能确定分配结果的，比方说以下一个计算阶乘的C代码片断：


```java
int factorial (int n) { 
    int tmp; 
    if (n <= 1) 
        return 1; 
    else { 
        tmp = n – 1; 
        tmp = n * factorial(tmp); 
        return tmp; 
    } 
} 

```
这段代码中，随着n的不同，tmp变量所需要的总内存空间大小是不同的，而且每次递归的时候tmp对应的内存单元都不同。诸如局部变量的栈式存储分配方法想必大家在学习C++或者汇编语言的时候已经有所了解，函数调用时的存储布局情况，请参考后面章节。

分析函数调用时候的存储布局情况我们不难发现，进行栈式存储分配的条件是在编译的时候需要知道一个函数的活动记录有多大（以便在进入函数的时候动态地分配活动记录的空间），如果这点不能满足，则应该使用堆式存储管理。

一般来说，栈区中的数据通常都是函数的活动记录，活动记录中的数据通常是使用寄存器偏址寻址方式进行访问的。所谓寄存器偏址寻址方式，即在一个基地址寄存器中存放着活动记录的首地址，在访问活动记录某一项内容的时候只需要使用该首地址以及该项内容相对这个首地址的偏移量即可计算出要访问的内容在内存中的实际逻辑地址。这类数据包括了函数的形式参数以及局部变量，具体细节请参考后续章节。

#### 堆区

堆是栈以外的另一种动态存储分配结构，它有两个基本的操作：申请内存和释放内存，C++的new和delete两个关键字即对应这两种功能。关于堆式管理在学术界和工业界都进行了广泛的研究和探索，有兴趣的同学可以参考Wikipedia的这个页面：

http://en.wikipedia.org/wiki/Dynamic_memory_allocation

堆式管理是应用程序在运行的时候通过向操作系统请求分配内存（例如UNIX中使用sbrk系统函数）和释放内存来实现的，因此分配和销毁都要占用相当的时间。在Decaf里面，数组和类对象都是在堆区上来分配内存空间的（因此需要用ALLOCATE运行时库函数）。
